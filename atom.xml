<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chenzdna.github.io</id>
    <title>阿征DNA</title>
    <updated>2022-04-27T05:08:52.953Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chenzdna.github.io"/>
    <link rel="self" href="https://chenzdna.github.io/atom.xml"/>
    <subtitle>修炼大魔法师</subtitle>
    <logo>https://chenzdna.github.io/images/avatar.png</logo>
    <icon>https://chenzdna.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 阿征DNA</rights>
    <entry>
        <title type="html"><![CDATA[[GoFrame] 使用 chunked 实现即时通信踩坑记录]]></title>
        <id>https://chenzdna.github.io/post/goframe-shi-yong-chunked-shi-xian-ji-shi-tong-xin/</id>
        <link href="https://chenzdna.github.io/post/goframe-shi-yong-chunked-shi-xian-ji-shi-tong-xin/">
        </link>
        <updated>2022-04-26T10:47:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前置知识">前置知识</h1>
<h2 id="http-响应格式">http 响应格式</h2>
<p>第一行是状态行，比如说响应 200 就是</p>
<pre><code>HTTP/1.1 200 OK
</code></pre>
<p>不空行，后面是响应头</p>
<pre><code>Connection: keep-alive
Transfer-Encoding: chunked
......
</code></pre>
<p>空一行，后面是响应体。</p>
<h2 id="什么是-chunked">什么是 chunked</h2>
<p>分块传输 <code>Transfer-Encoding: chunked</code> 表示这个请求返回的数据较大，服务端会边生成数据边传输，这就可以用来实现服务端主动给客户端推送消息。</p>
<p>编码格式为</p>
<pre><code>响应行
响应头
（空行）
响应体
</code></pre>
<p>其中响应体的编码格式为</p>
<pre><code>（假设响应数据为字符串s）
fmt.Sprintf(&quot;%x\r\n&quot;,len(s))
fmt.Sprintf(&quot;%s\r\n&quot;,s)
</code></pre>
<p>每段响应体的第一行是响应数据比特流长度的 16 进制表示，第二行是响应数据本体。</p>
<h1 id="开整">开整</h1>
<h2 id="vite-关闭连接-connection-closed">vite 关闭连接 <code>Connection: closed</code></h2>
<p>项目地址<a href="https://github.com/ChenzDNA/simple_chat_room">在这里</a>。</p>
<p>废话少说，操着 <code>IntelliJ IDEA</code> 就开始撸码。</p>
<p>后端使用的是 <code>GoFrame</code>，先给请求头加上 <code>Transfer-Encoding: chunked</code>，然后把 <code>Response</code> 对象保存起来以便服务端主动给客户端发消息。</p>
<p>前端使用 <code>Vue3+TypeScript</code> 开发，用 <code>vite</code> 做开发服务器并配好跨域。由于 <code>chunked</code> 连接在接受消息的时候 <code>XMLHttpRequest</code>( 后简称为 <code>xhr</code>) 的 <code>readyState</code> 属性并没有跳到 4，而是一直触发 3，所以并不能用 <code>axios</code> 来请求，只能自己封装一个。</p>
<p>意想不到的事情发生了，连接被关掉了。客户端和服务端谁关的连接？没看到响应头有 <code>chunked</code> 嘛？在浏览器查看响应头的 <code>Connection</code> 值为 <code>closed</code>，而请求头是 <code>Connection: keep-alive</code>，<code>GoFrame</code> 是不是你？</p>
<p>我于是开始了漫长的逮 bug 之旅。经过无数次在源码打断点、log 信息之后得出结论：<strong><code>Connection</code> 在进入后端的时候就已经为 <code>closed</code></strong>。麻了，关连接的既不是服务端也不是客户端，而是 <code>vite</code>。</p>
<p>烦内，先睡觉了。</p>
<p>确定是 <code>vite</code> 在代理的时候会把连接关闭，于是不用 <code>vite</code> 做跨域了，设置 <code>xhr.withCredentials=true</code>，话说我这是简单请求啊，前端不需要加跨域。</p>
<p>好，这次响应头有 <code>Connection: keep-alive</code> 了。不过断连接的问题还是没有解决。于是又开始漫长的翻 <code>GoFrame</code> 源码，试图找到 <code>connection.Close()</code> 之类的蛛丝马迹。</p>
<p>然后没找到。</p>
<p>于是开始必应。</p>
<h2 id="connection-keep-alive但是服务端关闭连接"><code>Connection: keep-alive</code>，但是服务端关闭连接</h2>
<p>我的好必应，让我找到了用 <code>gin</code> 实现 <code>chunked</code> 通信的示例代码，我又充满了决心。</p>
<p>用 <code>gin</code> 实践了一下确实可行，正当我想换框架的时候我一个突发奇想，开一个协程继续往 <code>Response</code> 里写数据，看前端会不会响应。</p>
<p>然后连接又又被关了。在 handler 函数返回之后，连接就关了。那应该不是框架的问题。于是又开始必应。</p>
<p>终于，在 github goframe <code>issue</code> 里面找到了 <code>chunked</code> 通信的示例代码，原来要拿到底层的 <code>ResponseWriter</code>。蹂躏了一番键盘，出现了和 <code>gin</code> 一样的问题。所以我的方向错了，问题应该出在比框架还要底层的东西。</p>
<p>遇到困难睡大觉。</p>
<h2 id="使用-hijack-解决">使用 Hijack 解决</h2>
<p>新一天，上课的时候无聊看 go 语言标准库文档，看到 <code>net/http</code> 库里有一个 <code>type Hijacker</code>，我又充满了决心。</p>
<p>这个 <code>Hijack()</code> 函数好几把难用，也真踏马刺激。直接让操作者接管连接，调用的这个方法后框架就不会对连接进行操作，就连调用框架封装好的 <code>Writer</code> 也直接报错。</p>
<p>行吧，现在知道开头为啥要讲 <code>http</code> 响应的编码格式了吧，我还得手搓 <code>http</code> 响应。</p>
<p>由于接管了连接，跨域也得手动搓：</p>
<pre><code>access-control-allow-credentials: true
access-control-allow-headers: ......
access-control-allow-methods: GET,PUT,POST,DELETE,OPTIONS
access-control-allow-origin: request.Header.Get(&quot;Origin&quot;)
</code></pre>
<p>然后保存，这次连接不会断了，除非调用 <code>connection.Close()</code> 方法。</p>
<h1 id="不足之处">不足之处</h1>
<h2 id="关于何时断开连接">关于何时断开连接</h2>
<p>只用 <code>GoFrame</code> 也不是不能做，就是有点麻烦，首先得开一个计时的协程，<code>time</code> 库有封装好的，然后监听前端的心跳，如果预定的时间过后没收到心跳就断开连接。问题是有多少个连接就要开多少个协程，虽然协程的消耗非常少，但还是不想这么做。</p>
<p>于是就想到了 <code>Redis</code>，可以监听 <code>Redis</code> 的键过期事件来断开对应的连接。缺点是还要额外开一个 <code>Redis</code>，还是有点麻烦。于是就偷懒在前端加了一个退出的按钮来关闭连接。</p>
<h2 id="关于性能">关于性能</h2>
<p>我也不知道如何测试 <code>chunked</code> 和 <code>websocket</code> 的性能，哪天再必应一下吧。</p>
<p>2022-04-26</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 使用枚举类与单例模式优化 if else 分支]]></title>
        <id>https://chenzdna.github.io/post/java-shi-yong-mei-ju-lei-yu-dan-li-mo-shi-you-hua-ye-wu-luo-ji/</id>
        <link href="https://chenzdna.github.io/post/java-shi-yong-mei-ju-lei-yu-dan-li-mo-shi-you-hua-ye-wu-luo-ji/">
        </link>
        <updated>2022-03-25T12:36:16.000Z</updated>
        <content type="html"><![CDATA[<p>由于碰到了这样的需求，我又有点设计强迫症，故研究了一下。灵感来自我之前写的一个小工具 <a href="https://github.com/ChenzDNA/pypadb">pypadb</a>。实际上这种方法只适用于简单地查个数据然后返回给前端，要做修改的话还是需要判断查出来的类型再做强制类型转换。</p>
<p>业务需求：根据前端传的一个代表数据种类的字符串和若干查询参数来查询不同表里的数据。</p>
<p>一般来说可以用 if else 判断字符串来处理，但是这样在表比较多的时候会造成 if else 过多，而且 if else 里面还有可能嵌套其他的 if else，看着就头大。所以这次来介绍一个用枚举类来优化 if else 分支的方法。</p>
<p>使用了 <a href="https://www.mybatis-plus.com/">Mybatis-Plus</a> 和 <a href="https://projectlombok.org/">lombok</a> 简化演示的代码，<code>Spring Boot Starter Test</code> 用来单元测试。</p>
<h1 id="预设">预设</h1>
<p>先上表结构（预先填了一列数据）：</p>
<pre><code class="language-console">表 a
+-----+--------+
| id  | data_a |
+-----+--------+
| 123 | aaaaaa |
+-----+--------+

表 b
+-----+--------+
| id  | data_b |
+-----+--------+
| 123 | bbbbbb |
+-----+--------+
</code></pre>
<p>实体类：</p>
<pre><code class="language-java">@Data
@TableName(&quot;a&quot;)
public class AEntity {
    @TableId
    String id;
    String dataA;
}

@Data
@TableName(&quot;b&quot;)
public class BEntity {
    @TableId
    String id;
    String dataB;
}
</code></pre>
<p>由于只是演示作用，就没写 Service 层了。实际开发中可以让所有 Service 或 Dao 都实现或继承一个接口，然后实现接口里的查询方法。</p>
<pre><code class="language-java">@Mapper
public interface ADao extends BaseMapper&lt;AEntity&gt; {
}

@Mapper
public interface BDao extends BaseMapper&lt;BEntity&gt; {
}
</code></pre>
<h1 id="关键代码">关键代码</h1>
<p>枚举类：</p>
<pre><code class="language-java">public enum TableEnum {
    a(ADao.class),
    b(BDao.class);

    private Class daoClass;

    private volatile BaseMapper dao;

    TableEnum(Class daoClass) {
        this.daoClass = daoClass;
    }

    public BaseMapper getDao() {
        if (dao == null) {
            synchronized (TableEnum.class) {
                if (dao == null) {
                    dao = (BaseMapper) IOCConfig.getBean(daoClass);
                }
            }
        }
        return dao;
    }
}
</code></pre>
<p>用到的单例模式加上了双重验证来防止并发问题。</p>
<p>对应的单元测试：</p>
<pre><code class="language-java">@SpringBootTest
class BlogdemosApplicationTests {
    public static String a = &quot;a&quot;;
    public static String b = &quot;b&quot;;
    public static String id = &quot;123&quot;;

    @Test
    void test1() {
        Object o1 = TableEnum.valueOf(a).getDao().selectById(id);
        Object o2 = TableEnum.valueOf(b).getDao().selectById(id);

        System.out.println(&quot;------- o1 -------&quot;);
        System.out.println(JSONObject.toJSONString(o1, true));
        System.out.println(&quot;------- o2 -------&quot;);
        System.out.println(JSONObject.toJSONString(o2, true));

        // 要修改查出来的数据只能判断类型然后强转。
        if (o1 instanceof AEntity) {
            System.out.println(&quot;o1 instance AEnitty&quot;);
        }
        if (o2 instanceof BEntity) {
            System.out.println(&quot;o2 instance BEnitty&quot;);
        }
    }
}
</code></pre>
<h1 id="一些思考">一些思考</h1>
<p>关于查出来的数据只能是 <code>Object</code> 类型这个问题，我想了一下，包括使用带泛型的普通类来模拟枚举类的行为，然后想通过反射来获取 <code>BaseMapper</code> 里对应的泛型，返回正确的类型。但是没想到怎么写。从宏观的角度看，想要解决这个问题，Jvm 就需要根据一个不知道是什么内容的字符串确定一个类型，静态类型语言的 Java 好像做不到这一点。</p>
<h1 id="附">附</h1>
<p>使用一般类来模拟枚举类的行为：</p>
<pre><code class="language-java">@Slf4j
public class Tables {
    private static Map&lt;String, Class&gt; classMap = new ConcurrentHashMap&lt;&gt;();
    private static Map&lt;String, BaseMapper&gt; daoMap = new ConcurrentHashMap&lt;&gt;();

    private static void initClassMap(Object... args) {
        if (args == null || args.length &lt; 2 || (args.length &amp; 1) == 1) {
            log.error(&quot;Invalid arguments.&quot;);
            return;
        }
        for (int i = 0; i &lt; args.length; i += 2) {
            classMap.put((String) args[i], (Class) args[i + 1]);
        }
    }

    static {
        initClassMap(
                &quot;a&quot;, ADao.class,
                &quot;b&quot;, BDao.class
        );
    }

    public static BaseMapper valueOf(String table) {
        if (!classMap.containsKey(table)) {
            return null;
        }
        BaseMapper dao = daoMap.get(table);
        if (dao == null) {
            dao = (BaseMapper) IOCConfig.getBean(classMap.get(table));
            daoMap.put(table, dao);
        }
        return dao;
    }
}
</code></pre>
<p>不像枚举类，一般类可以一步就拿到对应的 Dao，只不过后期想要修改或添加其他的表需要改 static 代码块里面的代码，相比于枚举类来说少了一点优雅。并发问题就交给 <code>ConcurrentHashMap</code> 来解决。</p>
<p>2022-03-25</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[装 Linux 系统后要做的事]]></title>
        <id>https://chenzdna.github.io/post/zhuang-linux-xi-tong-hou-yao-zuo-de-shi/</id>
        <link href="https://chenzdna.github.io/post/zhuang-linux-xi-tong-hou-yao-zuo-de-shi/">
        </link>
        <updated>2022-02-21T08:29:26.000Z</updated>
        <content type="html"><![CDATA[<p>在二奶机上捣鼓 Linux 系统，有时候删了系统文件，重装了几次系统。为了以后重装系统配东西不再东找西找，就写了这一篇总结一下，<strong>仅供参考</strong>。</p>
<h1 id="ssh-允许-root-用户远程登录">SSH 允许 root 用户远程登录</h1>
<p>一般来说是不建议 root 用户登录 SSH，但是我又没公网 ip，就这样了。</p>
<p>编辑 sshd 的配置文件：</p>
<p><code>vim /etc/ssh/sshd_config</code></p>
<p>找到 <code>PermitRootLogin</code>，设为 <code>yes</code>，记得去掉注释。</p>
<p>重启 ssh，或者重启电脑：</p>
<p><code>service sshd restart</code></p>
<h1 id="设置笔记本合盖不睡眠">设置笔记本合盖不睡眠</h1>
<p>编辑 <code>logind.conf</code>：</p>
<p><code>vim /etc/systemd/logind.conf</code></p>
<p>找到 <code>HandleLidSwitch</code>，改为 <code>ignore</code>，记得去掉注释。</p>
<p>重启服务，或重启电脑：</p>
<p><code>systemctl restart systemd-logind</code></p>
<h1 id="系统工具安装">系统工具安装</h1>
<pre><code class="language-bash">apt install -y lsof vim gcc default-jdk redis nginx mariadb nodejs ffmpeg
</code></pre>
<h1 id="python-依赖">Python 依赖</h1>
<pre><code class="language-bash">python3 -m pip install BeautifulSoup4 fastapi requests nb-cli pydantic nonebot2
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot 监听 Redis 的键过期事件]]></title>
        <id>https://chenzdna.github.io/post/spring-boot-jian-ting-redis-de-jian-guo-qi-shi-jian/</id>
        <link href="https://chenzdna.github.io/post/spring-boot-jian-ting-redis-de-jian-guo-qi-shi-jian/">
        </link>
        <updated>2022-02-21T07:35:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="redis-配置">Redis 配置</h1>
<h2 id="方法一-更改配置文件以配置文件启动">方法一、更改配置文件，以配置文件启动</h2>
<p>进入 Redis 安装目录，修改 <code>redis.windows.conf</code> (Linux 下配置文件是 <code>redis.conf</code>)</p>
<p>在第892行找到 <code>notify-keyspace-events</code> (Windows 系统，Redis 版本 5.0.10)</p>
<p><code>notify-keyspace-events &quot;&quot;</code></p>
<p>上面有配置项的注释</p>
<pre><code>K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.
E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.
g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
$     String commands
l     List commands
s     Set commands
h     Hash commands
z     Sorted set commands
x     Expired events (events generated every time a key expires)
e     Evicted events (events generated when a key is evicted for maxmemory)
A     Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.
</code></pre>
<p>配置此项为键事件过期通知</p>
<p><code>notify-keyspace-events Ex</code></p>
<p>以配置文件启动</p>
<p><code>redis-server redis.windows.conf</code></p>
<h2 id="方法二-在-redis-cli-中配置">方法二、在 redis-cli 中配置</h2>
<p>运行 <code>redis-cli</code>，运行命令</p>
<p><code>config set notify-keyspace-events Ex</code></p>
<p>或在终端直接运行命令</p>
<p><code>redis-cli config set notify-keyspace-events Ex</code></p>
<h1 id="spring-boot-监听">Spring Boot 监听</h1>
<h2 id="引入依赖">引入依赖</h2>
<pre><code class="language-xml">&lt;!-- maven --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-json">// gradle
compile(&quot;org.springframework.boot:spring-boot-starter-data-redis&quot;)
</code></pre>
<h2 id="redismessagelistenerjava">RedisMessageListener.java</h2>
<pre><code class="language-java">@Component
public class RedisMessageListener implements MessageListener {
    @Resource
    private RedisTemplate&lt;String, Object&gt; redis;

    @Override
    public void onMessage(Message message, byte[] pattern) {
        System.out.println(&quot;----------- &quot; + new String(pattern));
        // 使用了 fastjson 来打印对象
        System.out.println(JSONObject.toJSONString(message, true));
        System.out.println(&quot;-------------------------------&quot;);
        // 获取过期的键
        System.out.println(redis.getValueSerializer().deserialize(message.getBody()));
    }
}
</code></pre>
<h2 id="redisconfigjava">RedisConfig.java</h2>
<pre><code class="language-java">@Configuration
public class RedisConfig {
    @Resource
    private RedisMessageListener messageListener;

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(redisConnectionFactory);

        template.setKeySerializer(new StringRedisSerializer());
        final Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);
        template.setValueSerializer(serializer);

        return template;
    }

    @Bean
    public ChannelTopic channelTopic() {
        // 监听 Redis 键过期事件通知
        return new ChannelTopic(&quot;__keyevent@0__:expired&quot;);
    }

    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer(RedisConnectionFactory redisConnectionFactory) {
        RedisMessageListenerContainer redisMessageListenerContainer = new RedisMessageListenerContainer();
        redisMessageListenerContainer.setConnectionFactory(redisConnectionFactory);
        redisMessageListenerContainer.addMessageListener(messageListener, channelTopic());
        return redisMessageListenerContainer;
    }
}
</code></pre>
<h1 id="运行测试">运行测试</h1>
<h2 id="方法1-在-redis-cli-中操作">方法1、在 redis-cli 中操作</h2>
<p><code>set 123 456 PX 100</code></p>
<p>键 123，值 456，100ms 后过期，若 <code>PX</code> 设为 <code>EX</code> 则时间单位为秒。</p>
<h2 id="方法2-使用-spring-boot-操作">方法2、使用 Spring Boot 操作</h2>
<pre><code class="language-java">
@RestController
public class TestController {
    @Resource
    private RedisTemplate&lt;String, Object&gt; redis;

    @GetMapping(&quot;/redis&quot;)
    public void re() {
        ValueOperations&lt;String, Object&gt; ops = redis.opsForValue();
        ops.set(&quot;123&quot;, &quot;456&quot;);
        // 设置需要过期的键，过期时间，时间单位
        redis.expire(&quot;123&quot;, 100L, TimeUnit.MILLISECONDS);
    }
}
</code></pre>
<h2 id="运行结果">运行结果</h2>
<p>控制台打印</p>
<pre><code>----------- __keyevent@0__:expired
{
	&quot;body&quot;:&quot;MTIz&quot;,
	&quot;channel&quot;:&quot;X19rZXlldmVudEAwX186ZXhwaXJlZA==&quot;
}
-------------------------------
123
</code></pre>
<p>成功拿到过期的键 123。</p>
<h1 id="注意事项">注意事项</h1>
<p>Spring Boot 2.6 默认禁止了循环引用，需要配置开启循环引用。</p>
<pre><code class="language-yaml">spring:
  main:
    allow-circular-references: true
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pypadb 使用文档 #5、使用模块导入初始化 tables]]></title>
        <id>https://chenzdna.github.io/post/pypadb-shi-yong-wen-dang-5shi-yong-mo-kuai-dao-ru-chu-shi-hua-tables/</id>
        <link href="https://chenzdna.github.io/post/pypadb-shi-yong-wen-dang-5shi-yong-mo-kuai-dao-ru-chu-shi-hua-tables/">
        </link>
        <updated>2022-02-04T15:41:27.000Z</updated>
        <content type="html"><![CDATA[<p>这个算更新的内容，所以就没改以前写的初始化 tables 了。</p>
<p>使用之前的例子：</p>
<pre><code class="language-python">from typing import Optional as _Optional

from pydantic import BaseModel as _BaseModel


class Stuff(_BaseModel):
    test_id: int
    name: str
    count: int


class Test(_BaseModel):
    id: _Optional[int]
    content: str
    stuffs: _Optional[list[StuffWuhu]]
    ctime: _Optional[int]
    mtime: _Optional[int]
</code></pre>
<p>把这两个类写到一个模块里面，注意 <code>import</code> 导包要转为下划线开头的包名，以免 pypadb 识别错误。</p>
<pre><code class="language-python">from pypadb.conf.table_configurer import tables

# 那两个类所在的包
import entities

if __name__ == '__main__':
    # 初始化tables
    tables.init_tables(entities)
    # tables.test
    # tables.stuff
    print(tables.tables)
</code></pre>
<p>这种初始化会把驼峰命名的类名转成下划线来使用，也可以设置参数 <code>escape_upper=True</code> 不处理驼峰命名。</p>
<p>2022-02-04</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pypadb 使用文档 #4、使用 tables 查询]]></title>
        <id>https://chenzdna.github.io/post/pypadb-shi-yong-wen-dang-4shi-yong/</id>
        <link href="https://chenzdna.github.io/post/pypadb-shi-yong-wen-dang-4shi-yong/">
        </link>
        <updated>2022-01-30T12:14:20.000Z</updated>
        <content type="html"><![CDATA[<p>查询想对来说比较复杂，需要一些类来辅助。</p>
<p>首先有三个方法：</p>
<pre><code class="language-python">def select_one(self, extra=None, **kwargs):
    pass

def select_many(self, limit: Limit = None, extra=None, **kwargs) -&gt; list:
    pass

def select_like(self,
                likes: Union[list[Like], Like] = {},
                limit: Limit = None,
                extra=None) -&gt; list:
    pass
</code></pre>
<ul>
<li><code>select_one</code> 查询单个对象。</li>
<li><code>select_many</code> 查询多个对象，把结果集中的内容以 <code>list</code> 的形式返回。</li>
<li><code>select_like</code> 模糊查询，总是以 <code>list</code> 的形式返回。</li>
</ul>
<p>为了方便演示，在 <a href="/post/pypadb-shi-yong-wen-dang-2">pypadb 使用文档 #2</a> 的表和实体类的基础上新增如下表和实体类：</p>
<pre><code class="language-sql">create table stuff
(
    test_id bigint       not null,
    name    varchar(20)  null,
    count   int unsigned null
);
</code></pre>
<pre><code class="language-python"># 新增 Stuff 类对应 stuff 表
class Stuff(BaseModel):
    test_id: int
    name: str
    count: int

# 修改 Test，新增 stuffs 属性
class Test(BaseModel):
    id: Optional[int]
    content: str
    stuffs: Optional[list[Stuff]]
    ctime: Optional[int]
    mtime: Optional[int]
</code></pre>
<p><code>test</code> 表里的 <code>id</code> 属性对应 <code>stuff</code> 表里的 <code>test_id</code>，在查询 <code>test</code> 表时应该把对应的 <code>Stuff</code> 对象都查出来。</p>
<h1 id="初始化">初始化</h1>
<pre><code class="language-python">from pypadb.conf.table_configurer import tables

tables.init_tables(stuff=Stuff, test=Test)
</code></pre>
<h1 id="select_one">select_one</h1>
<pre><code class="language-python"># 不带任何参数，返回表中的第一条数据（应该没人用这个）
tables.test.select_one()

# 使用 extra
from pypadb.utils.conditions import extra

tables.test.select_one(
    id=1,
    extra=extra(column=['id', 'test_id'],
                data_property='stuffs',
                method=tables.stuff.select_many)
)

# 传入查询条件
tables.tset.select_one(id=1)
</code></pre>
<p>参数 <code>extra</code> 比较特殊，它接受 <code>pypadb.utils.conditions.extra</code> 函数返回的值并进行对应的处理。</p>
<p><code>pypadb.utils.conditions.extra</code> 函数接受三个参数 <code>column</code>、<code>data_property</code>、<code>method</code>。</p>
<ul>
<li><code>column</code>：一个长度为 2 的数组，值为 [当前调用表的列名, 需要额外查询的表的列名]。当前表和额外表是一对多的关系。</li>
<li><code>data_property</code>：需要填充的属性名。</li>
<li><code>method</code>：查询的方法。</li>
</ul>
<p><code>select_one</code> 在处理 <code>extra</code> 的时候会调用查询的方法，自动填充当前表查询出来的属性。</p>
<p>如上面的示例代码，把所有 <code>stuff</code> 表里 <code>test_id</code> 为 1 的数据全查出来填充到结果里的 <code>stuffs</code> 属性里。</p>
<h1 id="select_many">select_many</h1>
<pre><code class="language-python">from pypadb.utils.conditions import Limit

tables.test.select_many(limit=Limit(0, 1))
</code></pre>
<p><code>select_many</code> 只是比 <code>select_one</code> 多一个可选参数 <code>limit</code>。</p>
<p>顾名思义，<code>limit</code> 是用来做查询分页的，<code>Limit(start, count)</code> 会解析成 <code>limit %(start)s, %(count)s</code>，其中 <code>count</code> 为可选参数，若不传 <code>count</code> 则会解析成 <code>limit %(start)s</code></p>
<h1 id="select_like">select_like</h1>
<pre><code class="language-python">from pypadb.utils.conditions import Like
from pypadb.utils.enums import LikeEnum

tables.test.select_like(likes=Like('content', '1', LikeEnum.ALL_Like))
</code></pre>
<p><code>select_like</code> 相比 <code>select_many</code>，多了一个参数 <code>likes</code>，接受的值可以为 <code>Like</code> 或 <code>list[Like]</code>。若以 <code>list[Like]</code> 的形式传参，则模糊查询之间以 <code>or</code> 相连，即所有的模糊匹配都会生效。</p>
<p><code>Like(column, value, like_type)</code> 需要指定模糊查询的列名，并传一个模糊查询的值。会根据 <code>like_type</code> 来解析左右模糊匹配或者全模糊匹配。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pypadb 使用文档 #3、初始化 tables && 使用 tables 增删改]]></title>
        <id>https://chenzdna.github.io/post/pypadb-shi-yong-wen-dang-3chu-shi-hua-tables/</id>
        <link href="https://chenzdna.github.io/post/pypadb-shi-yong-wen-dang-3chu-shi-hua-tables/">
        </link>
        <updated>2022-01-30T10:19:22.000Z</updated>
        <content type="html"><![CDATA[<p>沿用 <a href="/post/pypadb-shi-yong-wen-dang-2">pypadb 使用文档 #2</a> 的表和实体类，这一篇将会使用 <code>pypadb.conf.table_configurer.tables</code> 来进行实体类和表的映射，极大的增加编写 CURD 的效率。</p>
<h1 id="初始化">初始化</h1>
<pre><code class="language-python">from pypadb.conf.table_configurer import tables

tables.init_tables(test=Test)
</code></pre>
<p><code>init_tables</code> 以 <strong>表名=类</strong> 的形式接受一些 <code>kwargs</code>，可以多次调用，重复的值会覆盖。</p>
<p>在调用后可以用 <code>tables.test</code> 或者 <code>tables['test']</code> 的形式操作数据表。</p>
<h1 id="insert">insert</h1>
<pre><code class="language-python"># 单个插入
tables.test.insert(Test(content='123'))
# 批量插入
tables.test.insert([Test(content='111'), Test(content='222')])
</code></pre>
<p><code>insert</code> 方法接受一个参数作为插入的实体对象，可以为一个对象或者 <code>list</code>。返回插入后的主键。为 <code>list</code> 时返回值为最后插入的主键。</p>
<h1 id="update">update</h1>
<pre><code class="language-python"># 更新 id 为 1 的数据
tables.test.update(Test(content='333'), id=1)
</code></pre>
<p><code>update</code> 方法第一个参数为修改的实体对象，后面还有若干 kwargs 作为查询条件。</p>
<p>需要注意的是，查询条件为空时 <code>update</code> 方法不会修改任何值。</p>
<h1 id="delete">delete</h1>
<pre><code class="language-python"># 删除 id 为 1 的数据
tables.test.delete(id=1)
</code></pre>
<p>和 <code>update</code> 方法相同，kwargs 为空时 <code>delete</code> 方法不会进行任何操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pypadb 使用文档 #2、使用装饰器进行增删改查操作]]></title>
        <id>https://chenzdna.github.io/post/pypadb-shi-yong-wen-dang-2/</id>
        <link href="https://chenzdna.github.io/post/pypadb-shi-yong-wen-dang-2/">
        </link>
        <updated>2022-01-29T07:35:35.000Z</updated>
        <content type="html"><![CDATA[<p>pypadb 提供了 <code>@insert</code>、<code>@update</code>、<code>@delete</code>、<code>@select</code> 四个装饰器来扩展函数。</p>
<p>有如下表结构：</p>
<pre><code class="language-sql">create table test
(
    id      int unsigned auto_increment primary key,
    content varchar(255) null,
    ctime   bigint       null,
    mtime   bigint       null
);
</code></pre>
<p>实体类如下：</p>
<pre><code class="language-python">class Test(BaseModel):
    id: Optional[int]
    content: str
    ctime: Optional[int]
    mtime: Optional[int]
</code></pre>
<ul>
<li>实体类须继承 <code>pydantic.BaseModel</code>。</li>
<li>实体类的属性须添加类型注释。</li>
<li>可以为 <code>None</code> 的属性或- 不在数据库表里的属性须用 <code>Optional</code> 包裹。</li>
</ul>
<h1 id="insert">@insert</h1>
<pre><code class="language-python">from pypadb.decorator import insert

@insert('insert into test(content,ctime)')
def ins_test(test: Union[list[Test], Test]):
    # 在 insert 前修改 ctime（创建时间）为当前时间
    test.ctime = int(datetime.datetime.now().timestamp() * 1000)

# 单个插入
ins_test(Test(content='wow'))
# 批量插入
ins_test([Test(content='wow'), Test(content='123456')])
</code></pre>
<p><code>@insert</code> 装饰器接受一个参数 <code>sql: str</code>，要表明插入时的列名。</p>
<p>被装饰的函数只接受一个参数，可以为 <code>Test</code> 或者 <code>list[Test]</code>，装饰器在处理的时候会判断是否进行批量插入。</p>
<p>函数体可以为 <code>pass</code>，如果函数体不为空，则会在插入前调用函数，例如上面的代码，在插入前初始化 <code>ctime</code> 字段为当前时间。对于 <code>list[Test]</code>，装饰器同样会在插入前对每一个实体类进行处理。</p>
<p>函数的返回值是修改的最后一行主键值。</p>
<h1 id="update">@update</h1>
<pre><code class="language-python">from pypadb.decorator import update

@update('update test')
def upd_test(test: Test):
    # 在 update 前修改 mtime （修改时间）为当前时间
    test.mtime = int(datetime.datetime.now().timestamp() * 1000)

# 实体类，查询条件1，查询条件2 ...
upd_test(Test(content='wuhu'), id=1)
</code></pre>
<p><code>@update</code> 接受一个参数 <code>sql: str</code>，只需要写上需要更新的表，装饰器会根据传进来的实体对象动态生成 sql 语句。即实体对象的属性值为 <code>None</code>、空数组或者空字符串时，<code>@update</code> 会忽略这一属性。需要注意的是，若属性值为 0 时，<code>@update</code> 也会进行更新。</p>
<p>函数体可以为 <code>pass</code>，如果函数体不为空，则会在插入前调用函数，例如上面的代码，在插入前初始化 <code>mtime</code> 字段为当前时间。对于 <code>list[Test]</code>，装饰器同样会在插入前对每一个实体类进行处理。</p>
<p>被装饰的函数接受一个参数作为实体对象，还有若干指定参数作为查询条件。</p>
<p>函数的返回值是修改时的主键值。</p>
<h1 id="delete">@delete</h1>
<pre><code class="language-python">from pypadb.decorator import delete

@delete('delete from test where id=%(id)s')
def del_test(id: int = 0):
    pass
</code></pre>
<p><code>@delete</code> 装饰器接受一个值 <code>sql: str</code>，要写全。装饰器会把函数的参数列表和调用函数传进来的值做匹配，处理成一个 <code>dict</code> 交给 <code>pymysql</code> 处理。</p>
<p><code>@delete</code> 同样支持在删除前调用被装饰的函数。</p>
<h1 id="select">@select</h1>
<pre><code class="language-python">from pypadb.decorator import select

# 查询返回单个对象
@select('select * from test where id=%(id)s', data_type=Test)
def sel_test_one(id: int) -&gt; Test:
    pass

# 查询返回数组
@select(
    'select * from test where content  like concat(\'%%\',%(concat)s,\'%%\')',
    data_type=Test
)
def sel_test_many(concat: str) -&gt; list[Test]:
    pass
</code></pre>
<p><code>@select</code> 装饰器接受 2 个参数，处理 sql 语句和 <code>@delete</code> 一样，第二个参数 <code>data_type</code> 是为了将查询出来的数据包装成对象。</p>
<p><code>@select</code> 装饰器会通过反射的方式拿到函数返回值的类型注释，判断其是否为 <code>list</code> 来决定返回值是否为 <code>list</code>。若查询结果有多个，函数的返回值类型注释不是 <code>list</code> 的话，装饰器只会取结果集中的首行包装成对象返回。</p>
<p>被装饰的函数不需要有函数体，对函数体不做处理。被装饰的函数的参数列表不需要加上类型注释，当然加了更严谨。</p>
<p>2022-01-29</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[papadb 使用文档 #1、安装和配置项]]></title>
        <id>https://chenzdna.github.io/post/papadb-shi-yong-wen-dang-1an-zhuang-he-pei-zhi-xiang/</id>
        <link href="https://chenzdna.github.io/post/papadb-shi-yong-wen-dang-1an-zhuang-he-pei-zhi-xiang/">
        </link>
        <updated>2022-01-25T20:22:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<p>pypadb 依赖于 DBUtils、pydandic、PyMySQL，建议使用虚拟环境，避免污染全局依赖。</p>
<p><code>pip install pypadb</code></p>
<h1 id="数据库连接配置">数据库连接配置</h1>
<p>数据库连接用的是 pymysql，使用 DBUtils 作为连接池。</p>
<p>pypadb.conf.db_configurer 里有一堆 setter，是用来做数据库连接池配置的。</p>
<p>由于篇幅原因就不写方法具体内容了，返回的是 self，所以支持链式调用的写法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>配置项</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_creator</td>
<td>配置连接数据库的模块</td>
<td>pymysql</td>
</tr>
<tr>
<td>set_maxconnections</td>
<td>连接池允许的最大连接数，0 和 None 表示不限制连接数</td>
<td>6</td>
</tr>
<tr>
<td>set_mincached</td>
<td>初始化时，链接池中至少创建的空闲的链接，0 表示不创建</td>
<td>2</td>
</tr>
<tr>
<td>set_maxcached</td>
<td>链接池中最多闲置的链接，0和None不限制</td>
<td>5</td>
</tr>
<tr>
<td>set_blocking</td>
<td>连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</td>
<td>True</td>
</tr>
<tr>
<td>set_maxusage</td>
<td>一个链接最多被重复使用的次数，None表示无限制</td>
<td>None</td>
</tr>
<tr>
<td>set_setsession</td>
<td>开始会话前执行的命令列表</td>
<td>[]</td>
</tr>
<tr>
<td>set_host</td>
<td>数据库服务端主机名</td>
<td>127.0.0.1</td>
</tr>
<tr>
<td>set_port</td>
<td>数据库服务端端口号</td>
<td>3306</td>
</tr>
<tr>
<td>set_user</td>
<td>数据库登录用户</td>
<td>root</td>
</tr>
<tr>
<td>set_password</td>
<td>数据库登录密码</td>
<td>123456</td>
</tr>
<tr>
<td>set_database</td>
<td>数据库名</td>
<td>test</td>
</tr>
<tr>
<td>set_charset</td>
<td>数据库连接使用的字符编码</td>
<td>utf8</td>
</tr>
<tr>
<td>set_cursor</td>
<td>数据库查询使用的指针类型</td>
<td>pymysql.cursors.DictCursor</td>
</tr>
</tbody>
</table>
<p>使用 DictCursor 作为默认指针的原因是 DictCursor 会把每一行的查询结果作为 dict 返回 <code>{'列名':'数据'}</code>，表结构改变时需要改动的代码少很多。</p>
<p>配置完后要调用 <code>end</code> 方法，初始化连接池。</p>
<p>完整的配置如下：</p>
<pre><code class="language-python">from pypadb.conf.db_configurer import db_configurer, DbConfigurer

db_configurer \
    .set_host('localhost') \
    .set_user('root') \
    .set_password('123456') \
    .set_database('test') \
    .end()

# 或者自己 new 一个对象
DbConfigurer() \
    .set_host('localhost') \
    .set_user('root') \
    .set_password('123456') \
    .set_database('test') \
    .end()
</code></pre>
<h1 id="数据表配置仅对象数据映射部分会用到">数据表配置（仅对象数据映射部分会用到）</h1>
<pre><code class="language-python">from pydantic import BaseModel
from pypadb.conf.table_configurer import tables


class User(BaseModel):
    id: int
    account: str
    stuffs: list = []

# 实体类必须继承 pydantic 的 BaseModel
class Stuff(BaseModel):
    user_id: int
    name: str
    count: int

# 真正的配置部分 表名=类名
tables.init_tables(user=User, stuff=Stuff)
# 使用表格配置的内容
tables.user.select_one()
tables.stuff.select_many()
</code></pre>
<p>使用数据表就不需要另外写什么类或者模块，表和类的映射配好后直接把表作为 tables 的属性进行调用。</p>
<p>2022-01-26</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 pypadb 的一些细节 #1]]></title>
        <id>https://chenzdna.github.io/post/guan-yu-pypadb-de-yi-xie-xi-jie-1/</id>
        <link href="https://chenzdna.github.io/post/guan-yu-pypadb-de-yi-xie-xi-jie-1/">
        </link>
        <updated>2022-01-22T19:01:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="名字">名字</h1>
<p>pypadb，听起来挺怪的，念也不好念，但这个名字是可以解释的。各位应该都听说过 JPA（Java Persistence API，Java 持久层应用程序编程接口 <s>好几把长</s>），是一个新的 Java ORM（Object Relational Mapping，对象-关系映射）规范（现在来说也不是很新，但是很好用）。所以pypadb 的 pypa 就是 Python Persistence API。为啥要加一个 db 呢，因为 PyPI （Python Package Index，Python 包的仓库）里面已经有一个包叫 pyPA 了，所以就加了一个 db 表示 Database，咱们是和数据库打交道的。</p>
<h1 id="初衷">初衷</h1>
<p>去年搞了一段时间的 QQ 机器人，用的是基于 Python 的框架 nonebot。功能渐渐地做多了，难免要用到数据库。正好那时候学了 Mybatis，想着在 Python 里有没有 Mybatis 一样的东西，找了一圈发现虽然说是有开发者开发了更方便地操作数据库的包，但是还是没达到我的心理预期。于是 pypadb 的开发就被提上了日程。</p>
<p>然后就是寒假开始试着用了 Mybatis Plus，在 Spring Boot 里兼容 Mybatis，而且写一些简单的 CURD（Create Update Retrieve Delete，数据库的操作）比 Mybatis 更好用，于是在 pypadb 里也加上了 Mybatis Plus 的写法。</p>
<h1 id="一些吐槽">一些吐槽</h1>
<p>首先是 Python 的类型注解，泛型和反射。Python 作为一个动态强类型语言，类型注解和泛型在编译和运行期毫无意义，唯一的用处是在敲代码的时候给类型提示而已。但是这类型啊，十分的珍贵。早期一些包 IDE 没有类型提示，写起来跟吃了💩一样，所以还是表上类型比较好。但是即使你能标的地方都表上了类型，还是有些地方 IDE 解析不了，以后再细说。</p>
<p>与 Java 不一样，Python 的泛型完全变成了另外一种类型 GenericAlias ，要判断一个泛型的 list 到底是哪种类型，只能把所有的泛型都给比较一遍 <s>好傻逼</s>。殊途同归，Python 拿不到泛型类里的泛型，所以干脆直接指定一个类作为要处理的泛型了，这样耦合度会增加，所以用了 pydantic 来解耦。</p>
<p>至于反射，我觉得还行。基本的功能都做到了，可以拿到函数的类型注解和返回值的类型注解，封装成工具模块后用起来还是挺好的。</p>
<h1 id="the-end">The End</h1>
<p>搞了几天，才把查询搞出来。实际上 JPA 这种东西是简化增删改的，只是我觉得写查询比较好玩所以就先把查询的写了。</p>
<p>话说 pypadb 也不算 ORM 的框架啊，我把 ORM 的部分都交给 pydantic 做了。它应该算啥呢。</p>
<p>2022-01-23</p>
]]></content>
    </entry>
</feed>