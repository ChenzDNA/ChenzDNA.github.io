<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chenzdna.github.io</id>
    <title>阿征DNA</title>
    <updated>2022-01-25T21:32:15.814Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chenzdna.github.io"/>
    <link rel="self" href="https://chenzdna.github.io/atom.xml"/>
    <subtitle>修炼大魔法师</subtitle>
    <logo>https://chenzdna.github.io/images/avatar.png</logo>
    <icon>https://chenzdna.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 阿征DNA</rights>
    <entry>
        <title type="html"><![CDATA[papadb 使用文档 #1、安装和配置项]]></title>
        <id>https://chenzdna.github.io/post/papadb-shi-yong-wen-dang-1an-zhuang-he-pei-zhi-xiang/</id>
        <link href="https://chenzdna.github.io/post/papadb-shi-yong-wen-dang-1an-zhuang-he-pei-zhi-xiang/">
        </link>
        <updated>2022-01-25T20:22:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<p>pypadb 依赖于 DBUtils、pydandic、PyMySQL，建议使用虚拟环境，避免污染全局依赖。</p>
<p><code>pip install pypadb</code></p>
<h1 id="数据库连接配置">数据库连接配置</h1>
<p>数据库连接用的是 pymysql，使用 DBUtils 作为连接池。</p>
<p>pypadb.conf.db_configurer 里有一堆 setter，是用来做数据库连接池配置的。</p>
<p>由于篇幅原因就不写方法具体内容了，返回的是 self，所以支持链式调用的写法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>配置项</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_creator</td>
<td>配置连接数据库的模块</td>
<td>pymysql</td>
</tr>
<tr>
<td>set_maxconnections</td>
<td>连接池允许的最大连接数，0 和 None 表示不限制连接数</td>
<td>6</td>
</tr>
<tr>
<td>set_mincached</td>
<td>初始化时，链接池中至少创建的空闲的链接，0 表示不创建</td>
<td>2</td>
</tr>
<tr>
<td>set_maxcached</td>
<td>链接池中最多闲置的链接，0和None不限制</td>
<td>5</td>
</tr>
<tr>
<td>set_blocking</td>
<td>连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</td>
<td>True</td>
</tr>
<tr>
<td>set_maxusage</td>
<td>一个链接最多被重复使用的次数，None表示无限制</td>
<td>None</td>
</tr>
<tr>
<td>set_setsession</td>
<td>开始会话前执行的命令列表</td>
<td>[]</td>
</tr>
<tr>
<td>set_host</td>
<td>数据库服务端主机名</td>
<td>127.0.0.1</td>
</tr>
<tr>
<td>set_port</td>
<td>数据库服务端端口号</td>
<td>3306</td>
</tr>
<tr>
<td>set_user</td>
<td>数据库登录用户</td>
<td>root</td>
</tr>
<tr>
<td>set_password</td>
<td>数据库登录密码</td>
<td>123456</td>
</tr>
<tr>
<td>set_database</td>
<td>数据库名</td>
<td>test</td>
</tr>
<tr>
<td>set_charset</td>
<td>数据库连接使用的字符编码</td>
<td>utf8</td>
</tr>
<tr>
<td>set_cursor</td>
<td>数据库查询使用的指针类型</td>
<td>pymysql.cursors.DictCursor</td>
</tr>
</tbody>
</table>
<p>使用 DictCursor 作为默认指针的原因是 DictCursor 会把每一行的查询结果作为 dict 返回 <code>{'列名':'数据'}</code>，表结构改变时需要改动的代码少很多。</p>
<p>配置完后要调用 <code>end</code> 方法，初始化连接池。</p>
<p>完整的配置如下：</p>
<pre><code class="language-python">from pypadb.conf.db_configurer import db_configurer, DbConfigurer

db_configurer \
    .set_host('localhost') \
    .set_user('root') \
    .set_password('123456') \
    .set_database('test') \
    .end()

# 或者自己 new 一个对象
DbConfigurer() \
    .set_host('localhost') \
    .set_user('root') \
    .set_password('123456') \
    .set_database('test') \
    .end()
</code></pre>
<h1 id="数据表配置仅对象数据映射部分会用到">数据表配置（仅对象数据映射部分会用到）</h1>
<pre><code class="language-python">from pydantic import BaseModel
from pypadb.conf.table_configurer import tables


class User(BaseModel):
    id: int
    account: str
    stuffs: list = []

# 实体类必须继承 pydantic 的 BaseModel
class Stuff(BaseModel):
    user_id: int
    name: str
    count: int

# 真正的配置部分 表名=类名
tables.init_tables(user=User, stuff=Stuff)
# 使用表格配置的内容
tables.user.select_one()
tables.stuff.select_many()
</code></pre>
<p>使用数据表就不需要另外写什么类或者模块，表和类的映射配好后直接把表作为 tables 的属性进行调用。</p>
<p>2022-01-26</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 pypadb 的一些细节 #1]]></title>
        <id>https://chenzdna.github.io/post/guan-yu-pypadb-de-yi-xie-xi-jie-1/</id>
        <link href="https://chenzdna.github.io/post/guan-yu-pypadb-de-yi-xie-xi-jie-1/">
        </link>
        <updated>2022-01-22T19:01:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="名字">名字</h1>
<p>pypadb，听起来挺怪的，念也不好念，但这个名字是可以解释的。各位应该都听说过 JPA（Java Persistence API，Java 持久层应用程序编程接口 <s>好几把长</s>），是一个新的 Java ORM（Object Relational Mapping，对象-关系映射）规范（现在来说也不是很新，但是很好用）。所以pypadb 的 pypa 就是 Python Persistence API。为啥要加一个 db 呢，因为 PyPI （Python Package Index，Python 包的仓库）里面已经有一个包叫 pyPA 了，所以就加了一个 db 表示 Database，咱们是和数据库打交道的。</p>
<h1 id="初衷">初衷</h1>
<p>去年搞了一段时间的 QQ 机器人，用的是基于 Python 的框架 nonebot。功能渐渐地做多了，难免要用到数据库。正好那时候学了 Mybatis，想着在 Python 里有没有 Mybatis 一样的东西，找了一圈发现虽然说是有开发者开发了更方便地操作数据库的包，但是还是没达到我的心理预期。于是 pypadb 的开发就被提上了日程。</p>
<p>然后就是寒假开始试着用了 Mybatis Plus，在 Spring Boot 里兼容 Mybatis，而且写一些简单的 CURD（Create Update Retrieve Delete，数据库的操作）比 Mybatis 更好用，于是在 pypadb 里也加上了 Mybatis Plus 的写法。</p>
<h1 id="一些吐槽">一些吐槽</h1>
<p>首先是 Python 的类型注解，泛型和反射。Python 作为一个动态强类型语言，类型注解和泛型在编译和运行期毫无意义，唯一的用处是在敲代码的时候给类型提示而已。但是这类型啊，十分的珍贵。早期一些包 IDE 没有类型提示，写起来跟吃了💩一样，所以还是表上类型比较好。但是即使你能标的地方都表上了类型，还是有些地方 IDE 解析不了，以后再细说。</p>
<p>与 Java 不一样，Python 的泛型完全变成了另外一种类型 GenericAlias ，要判断一个泛型的 list 到底是哪种类型，只能把所有的泛型都给比较一遍 <s>好傻逼</s>。殊途同归，Python 拿不到泛型类里的泛型，所以干脆直接指定一个类作为要处理的泛型了，这样耦合度会增加，所以用了 pydantic 来解耦。</p>
<p>至于反射，我觉得还行。基本的功能都做到了，可以拿到函数的类型注解和返回值的类型注解，封装成工具模块后用起来还是挺好的。</p>
<h1 id="the-end">The End</h1>
<p>搞了几天，才把查询搞出来。实际上 JPA 这种东西是简化增删改的，只是我觉得写查询比较好玩所以就先把查询的写了。</p>
<p>话说 pypadb 也不算 ORM 的框架啊，我把 ORM 的部分都交给 pydantic 做了。它应该算啥呢。</p>
<p>2022-01-23</p>
]]></content>
    </entry>
</feed>