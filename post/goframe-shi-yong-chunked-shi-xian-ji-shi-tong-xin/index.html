<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>[GoFrame] 使用 chunked 实现即时通信踩坑记录 | 阿征DNA</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://chenzdna.github.io/favicon.ico?v=1651036539961">
<link rel="stylesheet" href="https://chenzdna.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="前置知识
http 响应格式
第一行是状态行，比如说响应 200 就是
HTTP/1.1 200 OK

不空行，后面是响应头
Connection: keep-alive
Transfer-Encoding: chunked
........." />
    <meta name="keywords" content="后端,Golang,GoFrame,踩坑记录" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://chenzdna.github.io">
        <img src="https://chenzdna.github.io/images/avatar.png?v=1651036539961" class="site-logo">
        <h1 class="site-title">阿征DNA</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
        
          <a href="/post/you-hao-de-di-fang" class="site-nav">
            出没
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      修炼大魔法师
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://chenzdna.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">[GoFrame] 使用 chunked 实现即时通信踩坑记录</h2>
            <div class="post-date">2022-04-26</div>
            
              <div class="feature-container" style="background-image: url('https://chenzdna.github.io/post-images/goframe-shi-yong-chunked-shi-xian-ji-shi-tong-xin.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <h1 id="前置知识">前置知识</h1>
<h2 id="http-响应格式">http 响应格式</h2>
<p>第一行是状态行，比如说响应 200 就是</p>
<pre><code>HTTP/1.1 200 OK
</code></pre>
<p>不空行，后面是响应头</p>
<pre><code>Connection: keep-alive
Transfer-Encoding: chunked
......
</code></pre>
<p>空一行，后面是响应体。</p>
<h2 id="什么是-chunked">什么是 chunked</h2>
<p>分块传输 <code>Transfer-Encoding: chunked</code> 表示这个请求返回的数据较大，服务端会边生成数据边传输，这就可以用来实现服务端主动给客户端推送消息。</p>
<p>编码格式为</p>
<pre><code>响应行
响应头
（空行）
响应体
</code></pre>
<p>其中响应体的编码格式为</p>
<pre><code>（假设响应数据为字符串s）
fmt.Sprintf(&quot;%x\r\n&quot;,len(s))
fmt.Sprintf(&quot;%s\r\n&quot;,s)
</code></pre>
<p>每段响应体的第一行是响应数据比特流长度的 16 进制表示，第二行是响应数据本体。</p>
<h1 id="开整">开整</h1>
<h2 id="vite-关闭连接-connection-closed">vite 关闭连接 <code>Connection: closed</code></h2>
<p>项目地址<a href="https://github.com/ChenzDNA/simple_chat_room">在这里</a>。</p>
<p>废话少说，操着 <code>IntelliJ IDEA</code> 就开始撸码。</p>
<p>后端使用的是 <code>GoFrame</code>，先给请求头加上 <code>Transfer-Encoding: chunked</code>，然后把 <code>Response</code> 对象保存起来以便服务端主动给客户端发消息。</p>
<p>前端使用 <code>Vue3+TypeScript</code> 开发，用 <code>vite</code> 做开发服务器并配好跨域。由于 <code>chunked</code> 连接在接受消息的时候 <code>XMLHttpRequest</code>( 后简称为 <code>xhr</code>) 的 <code>readyState</code> 属性并没有跳到 4，而是一直触发 3，所以并不能用 <code>axios</code> 来请求，只能自己封装一个。</p>
<p>意想不到的事情发生了，连接被关掉了。客户端和服务端谁关的连接？没看到响应头有 <code>chunked</code> 嘛？在浏览器查看响应头的 <code>Connection</code> 值为 <code>closed</code>，而请求头是 <code>Connection: keep-alive</code>，<code>GoFrame</code> 是不是你？</p>
<p>我于是开始了漫长的逮 bug 之旅。经过无数次在源码打断点、log 信息之后得出结论：<strong><code>Connection</code> 在进入后端的时候就已经为 <code>closed</code></strong>。麻了，关连接的既不是服务端也不是客户端，而是 <code>vite</code>。</p>
<p>烦内，先睡觉了。</p>
<p>确定是 <code>vite</code> 在代理的时候会把连接关闭，于是不用 <code>vite</code> 做跨域了，设置 <code>xhr.withCredentials=true</code>，话说我这是简单请求啊，前端不需要加跨域。</p>
<p>好，这次响应头有 <code>Connection: keep-alive</code> 了。不过断连接的问题还是没有解决。于是又开始漫长的翻 <code>GoFrame</code> 源码，试图找到 <code>connection.Close()</code> 之类的蛛丝马迹。</p>
<p>然后没找到。</p>
<p>于是开始必应。</p>
<h2 id="connection-keep-alive但是服务端关闭连接"><code>Connection: keep-alive</code>，但是服务端关闭连接</h2>
<p>我的好必应，让我找到了用 <code>gin</code> 实现 <code>chunked</code> 通信的示例代码，我又充满了决心。</p>
<p>用 <code>gin</code> 实践了一下确实可行，正当我想换框架的时候我一个突发奇想，开一个协程继续往 <code>Response</code> 里写数据，看前端会不会响应。</p>
<p>然后连接又又被关了。在 handler 函数返回之后，连接就关了。那应该不是框架的问题。于是又开始必应。</p>
<p>终于，在 github goframe <code>issue</code> 里面找到了 <code>chunked</code> 通信的示例代码，原来要拿到底层的 <code>ResponseWriter</code>。蹂躏了一番键盘，出现了和 <code>gin</code> 一样的问题。所以我的方向错了，问题应该出在比框架还要底层的东西。</p>
<p>遇到困难睡大觉。</p>
<h2 id="使用-hijack-解决">使用 Hijack 解决</h2>
<p>新一天，上课的时候无聊看 go 语言标准库文档，看到 <code>net/http</code> 库里有一个 <code>type Hijacker</code>，我又充满了决心。</p>
<p>这个 <code>Hijack()</code> 函数好几把难用，也真踏马刺激。直接让操作者接管连接，调用的这个方法后框架就不会对连接进行操作，就连调用框架封装好的 <code>Writer</code> 也直接报错。</p>
<p>行吧，现在知道开头为啥要讲 <code>http</code> 响应的编码格式了吧，我还得手搓 <code>http</code> 响应。</p>
<p>由于接管了连接，跨域也得手动搓：</p>
<pre><code>access-control-allow-credentials: true
access-control-allow-headers: ......
access-control-allow-methods: GET,PUT,POST,DELETE,OPTIONS
access-control-allow-origin: request.Header.Get(&quot;Origin&quot;)
</code></pre>
<p>然后保存，这次连接不会断了，除非调用 <code>connection.Close()</code> 方法。</p>
<h1 id="不足之处">不足之处</h1>
<h2 id="关于何时断开连接">关于何时断开连接</h2>
<p>只用 <code>GoFrame</code> 也不是不能做，就是有点麻烦，首先得开一个计时的协程，<code>time</code> 库有封装好的，然后监听前端的心跳，如果预定的时间过后没收到心跳就断开连接。问题是有多少个连接就要开多少个协程，虽然协程的消耗非常少，但还是不想这么做。</p>
<p>于是就想到了 <code>Redis</code>，可以监听 <code>Redis</code> 的键过期事件来断开对应的连接。缺点是还要额外开一个 <code>Redis</code>，还是有点麻烦。于是就偷懒在前端加了一个退出的按钮来关闭连接。</p>
<h2 id="关于性能">关于性能</h2>
<p>我也不知道如何测试 <code>chunked</code> 和 <code>websocket</code> 的性能，哪天再必应一下吧。</p>
<p>2022-04-26</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://chenzdna.github.io/tag/hou-duan/" class="tag">
                    后端
                  </a>
                
                  <a href="https://chenzdna.github.io/tag/golang/" class="tag">
                    Golang
                  </a>
                
                  <a href="https://chenzdna.github.io/tag/goframe/" class="tag">
                    GoFrame
                  </a>
                
                  <a href="https://chenzdna.github.io/tag/cai-keng-ji-lu/" class="tag">
                    踩坑记录
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://chenzdna.github.io/post/java-shi-yong-mei-ju-lei-yu-dan-li-mo-shi-you-hua-ye-wu-luo-ji/">
                  <h3 class="post-title">
                    Java 使用枚举类与单例模式优化 if else 分支
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'e7a0503076500140eb19',
        clientSecret: 'ead801280c09997ad1f7c8d6c2d42f41bdfd8d0c',
        repo: 'ChenzDNA.github.io',
        owner: 'ChenzDNA',
        admin: ['ChenzDNA'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
